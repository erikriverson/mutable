################################################################################
#   Program Name:     mutable.R
#   Author:           Erik Iverson
#   Created:          06/22/2010
#
#   Last saved
#    Time-stamp:      <2010-10-06 14:45:04 eriki>
#
#   ** Generated by auto-insert on 06/22/2010 at 09:49:47**
################################################################################

parseFormula <- function(formula, data, subset) {
  ## why this option is set?  do we need it, or leave it up to user? 
  options(na.action = "na.pass")

  mf <- match.call(expand.dots = FALSE)
  m <- match(c("formula", "data", "subset"), names(mf), 0L)
  mf <- mf[c(1L, m)]
  mf[[1L]] <- as.name("model.frame")
  mf <- eval(mf, parent.frame(n = 2))

  Terms <- terms(formula)
  strat <- attr(Terms, "response")

  if(strat != 0)
    df.vars <- mf[-strat]                 #drop arg?
  else {
    df.vars <- mf
    mf$fake.strat <- gl(1, nrow(mf), labels = "")
    strat <- match("fake.strat", names(mf)) 
  }

  list(vars = df.vars, strat = mf[[strat]])
}

mutable <- function(x, ...) {
  if(missing(x))
    x <- NULL 
  UseMethod("mutable", x)
}

mutable.function <- function(x, ...) {
  do.call(x, list(...))
}

muStratSummary <- function(x, strat, data, ...) {
  UseMethod("muStratSummary")
}
 
muStratSummary.default <- function(x, strat, data, ...) {
  quant <- quantile(x, probs = c(.25, .5, .75), ...)
  attr(quant, "N") <- length(x)
  quant
}

muStratSummary.factor <- function(x, strat, data, ...) {
  tbl <- table(x, ...)
  attr(tbl, "N") <- length(x)
  tbl
}

`+.mutable` <- function(x, y) {
  if(!is.null(attr(y, "resolve")) && attr(y, "resolve")) {
    if(is.null(y$data))
      y$data <- x$data
    if(is.symbol(y$data))
      y$data <- eval(y$data)
    if(is.null(y$formula))
      y$formula <- x$formula
    if("subset" %in% names(y)) {
      y$data <- y$data[eval(y$subset, y$data),]
      y$subset <- NULL
    }
    y <- do.call(mutable.formula, y)
  }
  addelement <- function(x, y) {
    if(!is.matrix(y))
      y <- as.matrix(y)
    un <- union(rownames(x), rownames(y))
    xx <- as.data.frame(unclass(as.matrix(x)))
    yy <- as.data.frame(unclass(as.matrix(y)))
    xx[[".rns"]] <- rownames(x)
    yy[[".rns"]] <- rownames(y)
    mydf <- merge(xx, yy, by = ".rns", all = TRUE)
    mydf <- mydf[match(un, mydf[[".rns"]]), ]
    rns <- mydf[[".rns"]]
    ret <- as.matrix(mydf[!names(mydf) %in% ".rns"])
    rownames(ret) <- rns
    ret
  }
  mapvars <- c("plain", "latex", "html")
  ret <- mapply(addelement, x[mapvars], y[mapvars], SIMPLIFY = FALSE)
  ret$formula <- x$formula
  ret$data <- x$data
  attr(ret, "resolve") <- FALSE
  class(ret) <- c("mutable")
  ret
}

muStratTest <- function(x, strat, data, ...) {
  UseMethod("muStratTest")
}

muStratTest.default <- function(x, strat, data, round.digits = 2, ...) {
  round(t.test(x ~ strat, ...)$p.value, round.digits)
}

muStratTest.factor <- function(x, strat, data, round.digits = 2, ...) {
  round(chisq.test(x, strat, ...)$p.value, round.digits)
}

mulmCoef <- function(formula, data, round.digits = 2, ...) {
  ret <- round(coef(lm(formula, data, ...))[-1], round.digits)
  list(plain = ret, latex = ret, html = ret)
}

muStratTest <- function(x, strat, data, ...) {
  UseMethod("muStratTest")
}

muStratTest.default <- function(x, strat, data, round.digits = 2, ...) {
  round(t.test(x ~ strat, ...)$p.value, round.digits)
}

muStratTest.factor <- function(x, strat, data, round.digits = 2, ...) {
  round(chisq.test(x, strat, ...)$p.value, round.digits)
}

mutable.default <- function(x, ...) {
  m <- as.list(match.call())[-1]
  if(!"data" %in% names(m))
    lst <- c(list(formula = NULL, data = NULL), m)
  else
    lst <- c(list(formula = NULL), m)
  attr(lst, "resolve") <- TRUE
  lst
}

mutable.formula <- function(formula, data,
                            summary.function = muStratSummary,
                            plain.function = muStratPlain,
                            latex.function = muStratLatex,
                            html.function = muStratHTML, 
                            colname,
                            subset = NULL, ...) {

  ## if there was no data argument, we have to go find it first return
  ## from function knowing this, and resolve the data argument later,
  ## since we know `+.mutable.` must have been called. 
  
  if(missing(data)) {
    lst <- as.list(match.call()[-1])
    attr(lst, "resolve") <- TRUE
    return(lst)
  }

  m  <- as.list(match.call())[-1]
  if("subset" %in% names(m))
    pfargs <- list(m$formula, m$data, m$subset)
  else
    pfargs <- list(m$formula, m$data, NULL)
  pfargs[sapply(pfargs, is.null)] <- NULL
  
  dfv <- do.call(parseFormula, pfargs)

  table.vars <- strsplit(tail(as.character(formula), n = 1), " + ", fixed = TRUE)[[1]]

  xx <- NULL
  for(x in table.vars) {
      if(is.numeric(data[[x]])) {
        y <- x
      }
      if(is.factor(data[[x]])) {
        y <- c(x, paste(x, names(table(data[[x]])), sep = ""))
      }
      xx <- c(xx, y)
  }
  
  ret <- lapply(dfv$vars, summary.function, dfv$strat, data, ...)

  ## grab any defaults for formatting functions from the
  ## summary.function attributes we need to know which ones to grab
  ## though, probably through a list as as argument to this function.
  ## Or, we could just define any of them based on the attribute being
  ## present.  But how would we know which functions are actually
  ## meant to be called?  Perhaps intitial object can specify these.
  ## for now, just use our latex/html/format

  if(!is.null(lf <- attr(summary.function, "latex.function")))
    latex.function <- lf
  if(!is.null(hf <- attr(summary.function, "html.function")))
    html.function <- hf
  if(!is.null(ff <- attr(summary.function, "plain.function")))
    plain.function <- ff
  
  plain.ret <- NULL
  for(i in 1:length(ret)) {
    val <- plain.function(ret[[i]], names(ret)[i], data, colname = colname)
    plain.ret <- c(plain.ret, val)
  }
  plain.ret <- as.matrix(plain.ret[xx], ncol = 1)

  latex.ret <- NULL
  for(i in 1:length(ret)) {
    val <- latex.function(ret[[i]], names(ret)[i], data, colname = colname)
    latex.ret <- c(latex.ret, val)
  }
  latex.ret <- as.matrix(latex.ret[xx], ncol = 1)

  html.ret <- NULL
  for(i in 1:length(ret)) {
    val <- html.function(ret[[i]], names(ret)[i], data, colname = colname)
    html.ret <- c(html.ret, val)
  }
  html.ret <- as.matrix(html.ret[xx], ncol = 1)

  ## set the names of the matrix for printing 
  rownames(plain.ret) <- xx
  rownames(latex.ret) <- xx
  rownames(html.ret) <- xx
  if(!missing(colname)) {
    colnames(plain.ret) <- colname
    colnames(latex.ret) <- colname
    colnames(html.ret) <- colname
  }

  ## set up the return value (a list)
  return.list <- list(plain = plain.ret, latex = latex.ret, html = html.ret, 
                      formula = formula, data = data)
  attr(return.list, "resolve") <- FALSE
  class(return.list) <- c("mutable")
  return.list
}

print.mutable <- function(x, quote = FALSE, na.print = "--", print.rownames = FALSE, ...) {
  x <- x[["plain"]]
  if(!print.rownames)
    rownames(x) <- NULL
  print.default(unclass(x), quote = quote, na.print = na.print, ...)
}

muPrintIdentity <- function(x, name, data, ...) {
  ret <- x
  names(ret) <- name
  ret
}

muRownamesSummary <- function(x, ...) {
  UseMethod("muRownamesSummary")
}

muRownamesSummary.default <- function(x, ...) {
  label(x)
}

muRownamesSummary.factor <- function(x, ...) {
  ret <- c(label(x), levels(x))
  class(ret) <- "rowFactor"
  ret
}

muRownamesPlain <- function(x, ...) {
  UseMethod("muRownamesPlain")
}

muRownamesPlain.rowFactor <- function(x, name, data, ...) {
  ret <- c(x[1], paste("", tail(x, length(x) - 1)))
  names(ret) <- c(name, paste(name,  levels(data[[name]]), sep = ""))
  ret
}

muResponseSummary <- function(x, strat, data, ...) {
  UseMethod("muResponseSummary")
}
 
muResponseSummary.default <- function(x, strat, data, ...) {
  round(cor(x, strat), 2)
}

muResponseSummary.factor <- function(x, strat, data, ...) {
  ta <- tapply(strat, x, quantile, probs = c(.25, .5, .75))
  class(ta) <-  "muResponseSummaryFactor"
  ta
}

